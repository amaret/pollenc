#!/usr/bin/env python

# Copyright 2012, 2013 Amaret Inc. All rights reserved.

import sys
import subprocess
import shutil
import shlex
import argparse
import json
import zipfile
import os
import base64
import random
import socket
import time
import hashlib
import glob

def rmfile(f):
    try:
        os.remove(f)
    except:
        pass

def rmdir(d):
    try:
        shutil.rmtree(d)
    except:
        pass

class Pollenc:

    def getVerbose(self):
        if self.args.vvverbose == True:
            return 3
        if self.args.vverbose == True:
            return 2
        if self.args.verbose == True:
            return 1
        return 0

    def __init__ (self, args):
        self.bundleNames = []
        self.args = args
        self.workname = 'pollenc' + str(os.getpid()) + '_' + str(random.randint(1, 10000))
        self.workzip = '/tmp/' + self.workname + '_src.zip'
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((args.host, args.port))

    #
    # begin comm
    #
    def write(self, msg):
        hmsg = "%i\n%s" % (len(msg), msg)
        self.sock.send(hmsg)
    
    def read(self):

        hlen = 0
        hlenRec = ''
        while True:
            b = self.sock.recv(1)
            if b == '\n':
                hlen = int(hlenRec)
                break
            hlenRec += b
        
        BUFSZ = 1024
        r = ''
        while len(r) < hlen:
            sz = BUFSZ
            rem = hlen - len(r)
            if rem < BUFSZ:
                sz = rem
            b = self.sock.recv(sz)
            r += b
        return r
    #
    # end comm
    #

    def filenameOk(self, file):
        if file.endswith('.zip'):
            return False
        if file.endswith('stderr'):
            return False
        if file.endswith('stdout'):
            return False
        if file.endswith('.out'):
            return False
        if file.endswith('.hex'):
            return False
        return True

    def zipdir(self, path, zip):
        origpath = os.getcwd()
        os.chdir(path)
        namelist = ''
        for root, dirs, files in os.walk('.'):
            for file in files:
                if self.filenameOk(file):
                    namelist += root + '/'+ file + ' '
                    zip.write(os.path.join(root, file))
        if self.getVerbose() > 0:
            print('preparing %s' % (namelist))
        os.chdir(origpath)


    def makeCZip(self):

        zip = zipfile.ZipFile(self.workzip, 'w')
        ptmp = []
        if self.args.includes == None:
            ptmp.append('.')
        else:
            for d in self.args.includes:
                ptmp.append(d)

        tmpdir = '/tmp/' + self.workname
        for src in ptmp:
            rmdir(tmpdir)
            os.mkdir(tmpdir)
            shutil.copytree(src,tmpdir + '/code/')
            self.zipdir(tmpdir, zip)
            rmdir(tmpdir)
        zip.close()

    def zipBundles(self, zip, paths):
        tmpdir = '/tmp/' + self.workname
        for src in paths:
            if src.find('*')!=-1 or src.find('?')!=-1:
                wildcardLst = glob.glob(src)
                if len(wildcardLst) > 0:
                    self.zipBundles(zip, wildcardLst) #recurse for wildcard
                    continue
            if not os.path.exists(src):
                self.bundleNames.append(src)
                continue #system bundle
            rmdir(tmpdir)
            bundleName = self.getBundleName(src)
            if bundleName in self.bundleNames:
                continue #dupe -i
            self.bundleNames.append(bundleName)
            shutil.copytree(src, tmpdir + '/' + bundleName)
            self.zipdir(tmpdir, zip)
            rmdir(tmpdir)

    def makePollenZip(self):
        zip = zipfile.ZipFile(self.workzip, 'w')
        if self.args.includes == None:
            raise Exception('-i required')

        self.zipBundles(zip, self.args.includes)
        
        zip.close()

    def getRelToTmpDirName(self):
        abspath = os.path.abspath(self.args.filename)
        (r, m) = os.path.split(abspath)
        l = abspath.split("/")
        llen = len(l)
        if llen < 3:
            raise Exception('filename must be in <bundle>/<package>')
        r = l[llen -3] + '/' + l[llen -2] + '/' + l[llen -1]
        return r

    def getBundleName(self, path):
        abspath = os.path.abspath(path)
        (r, m) = os.path.split(abspath)
        return m

    def makezip(self):
       
        rmfile(self.workzip)

        if self.args.buildc:
            self.makeCZip()
        else:
            self.makePollenZip()

    def sendzip(self):
        file = open(self.workzip, "rb")
        data = ''
        while True:
            chunk = file.read(1024)
            if not chunk: 
                break  # EOF
            data += chunk
        file.close()
        b64data = base64.b64encode(data)
        rmfile(self.workzip)
        
        if not os.path.exists(self.args.filename):
            print "Module " + self.args.filename + " not found"
            sys.exit()     

        tid = hashlib.sha1(str(time.time()) + '-' + self.args.token).hexdigest()
        jsonobj = {
                   'compiler': ('pollen_' if self.args.buildpollen else '') + 
                        ('any' if self.args.translateonly else self.args.buildcc.lower()), 
                   'tid': tid,
                   'aid': '%s-%s' % (self.args.token, tid),
                   'reply': 'dummy', 
                   'type': 'request', 
                   'service': 'compile', 
                   'user': {
                       'token': self.args.token, 
                       'id': 0, 
                       'name': 'None'
                       },
                   'project': {
                       'id': 0, 
                       'name': 'None'
                       }, 
                   'content' :  {
                       'source':  b64data, 
                       'filename': self.getRelToTmpDirName(),
                       'partnum': self.args.mcu
                       }
                   }
        if self.args.pollenEnv:
            jsonobj['content']['pollenEnv'] = self.args.pollenEnv
        if self.args.buildpollen:
            jsonobj['content']['bundlenames'] = self.bundleNames
        jsonobj['content']['getbuild'] = self.args.getbuild
        jsonobj['content']['verbose'] = self.getVerbose()
        jsonobj['content']['translateonly'] = self.args.translateonly
        if self.args.cflags != None:
            jsonobj['content']['cflags'] = self.args.cflags
        if self.args.setcflags != None:
            jsonobj['content']['setcflags'] = self.args.setcflags
        if self.args.ldflags != None:
            jsonobj['content']['ldflags'] = self.args.ldflags
        if self.args.setldflags != None:
            jsonobj['content']['setldflags'] = self.args.setldflags
        
        jsonstr = json.dumps(jsonobj)
        #print 'sending json:\n' + jsonstr + '\n'
        self.write(jsonstr)

    def run(self):

        self.makezip()
        self.sendzip()

        while True:
            r = self.read()
            workobj = json.loads(r)
            if workobj['type'] != 'response':
                print ('%s' % (workobj['content']['content']))
                continue
            if workobj['content']['error'] != 'None':
                print ('error! %s' % (workobj['content']['error']))
                return
            break
        
        rmfile(self.workzip)

        b64 = workobj['content']['content']
        zipbytes = base64.b64decode(b64)
        origpath = os.getcwd()
        os.chdir(self.args.outdir)
        unzip(zipbytes)
        os.chdir(origpath)
        self.printStdErr() #look for stderr and play msgs
        if self.args.loader != None:
            print "Loading hex...",
            self.loadHex()
            print "done."

    def getModulePath(self):
        pkg = self.getPackageName()
        mod = self.getModuleName()

        for bundle in self.args.includes:
            p = '%s/%s/%s.p' % (bundle, pkg, mod)
            if os.path.isfile(p):
                return p
        
        return None

    def getPackageName(self):
        parts = self.args.filename.rpartition('.')
        return parts[0]

    def getFilename(self):
        return self.args.filename

    def printStdErr(self):
        for root, dirs, files in os.walk(self.args.outdir):
            for f in files:
                if f.endswith('err'):
                    print 'msgs found in stderr from server:'
                    with open(root + '/' + f, 'r') as fin:
                        print fin.read()

    def findHexName(self):
        for root, dirs, files in os.walk(self.args.outdir):
            for file in files:
                if file.endswith('.hex'):
                    return root + '/' + file
        raise Exception('hex file not generated')

    def getHexName(self):
        if self.args.buildpollen:
            n = self.findHexName()
            return n
        n = self.args.outdir + '/' + self.getProgRootName() + '.out.hex'
        return n

    def getProgRootName(self):
        return os.path.splitext(self.getFilename())[0]

    def loadHex(self):
        
        cmd = 'downloader'
        if self.args.mcu != None:
            cmd += ' -t ' + self.args.mcu
        if self.args.serial != None:
            cmd += ' -s ' + self.args.serial
        if self.args.baud != None:
            cmd += ' -b ' + self.args.baud
        if self.args.loader != None:
            cmd += ' -p ' + self.args.loader
        cmd += ' -c flash:w:' + self.getHexName()

        pipeCmd(cmd)


def unzip (src):
    tmpzip = 'a.zip'
    try:
        binfile = open(tmpzip, 'wb')
        binfile.write(src)
        binfile.close()
        z = zipfile.ZipFile(tmpzip)
        z.extractall('.')
        rmfile(tmpzip)
    except Exception, e:
        print("argh! %s" % (e))

def pipeCmd(command):

    print("trying to run cmd: %s" % (command))
    commandOut = ""
    commandErr = ""
    try:
        process = subprocess.Popen(shlex.split(command), bufsize=4096, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (commandOut, commandErr) = process.communicate()
        process.wait()
    except Exception, e:
        print("Error! %s" % (str(e)))
        raise e;


if __name__ == "__main__":

    parser = argparse.ArgumentParser()

    parser.add_argument('-v', '--verbose', 
            dest='verbose', action='store_true', help='verbose')

    parser.add_argument('-vv', '--vverbose', 
            dest='vverbose', action='store_true', help='very verbose')

    parser.add_argument('-vvv', '--vvverbose', 
            dest='vvverbose', action='store_true', help='very very verbose')

    parser.add_argument('--build-c', 
            dest='buildc', action='store_true', help='build c')

    parser.add_argument('--translate-only', 
            dest='translateonly', 
            action='store_true', 
            help='no compile, return pollen generate files')

    parser.add_argument('--get-build', 
            dest='getbuild', action='store_true', help='return all build files')

    parser.add_argument('-l', '--loader', 
            dest='loader', action='store', help='loader')

    parser.add_argument('-b', '--baud', 
            dest='baud', action='store', help='baud')

    parser.add_argument('-s', '--serial', 
            dest='serial', action='store', help='serial port')

    parser.add_argument('--host', 
            dest='host', action='store', help='wind.io host', default="passage.wind.io")

    parser.add_argument('--port', 
            dest='port', action='store', help='wind.io port', default=2323, type=int)

    parser.add_argument('--cflags', 
            dest='cflags', action='store', help='append cflags')

    parser.add_argument('--set-cflags', 
            dest='setcflags', action='store', help='cflags')

    parser.add_argument('--ldflags', 
            dest='ldflags', action='store', help='append ldflags')

    parser.add_argument('--set-ldflags', 
            dest='setldflags', action='store', help='ldflags')

    parser.add_argument('-m', '--mcu',  
            dest='mcu', action='store', help='mcu', required=False)

    parser.add_argument('-e', '--environment', 
            dest='pollenEnv', action='store', help='Pollen environment', required=False)

    parser.add_argument('-c', '--compiler', 
            dest='buildcc', action='store', help='build environment', required=False)

    parser.add_argument('-t', '--token', 
            dest='token', action='store', help='user credential', required=True)

    parser.add_argument('-o', '--out', 
            dest='outdir', action='store', help='output dir', default='./build')

    parser.add_argument('-i', '--include',
            dest='includes', action='append', help='code dirs')

    parser.add_argument('filename', nargs='?')

    #todo:
    # cflags / setcflags
    # ldflags / setldlags
    # there is a problem tunneling - char in argparse
        
    args = parser.parse_args()

    if args.translateonly:
        args.getbuild = True
    if not args.translateonly:
        if args.buildcc == None:
            print('no --compiler (-c) specified')
            sys.exit(0)
        if args.mcu == None:
            print('no --mcu (-m) specified')
            sys.exit(0)

    if args.filename == None:
        print('no filename specified')
        sys.exit(0)

    if args.buildc == True:
        args.buildpollen = False
    else:
        args.buildpollen = True
        args.buildc == False
    
    if os.path.exists(args.outdir):
        rmdir(args.outdir)
    os.mkdir(args.outdir)

    Pollenc(args).run() 

