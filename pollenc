#!/usr/bin/env python

# Copyright 2012, 2013 Amaret Inc. All rights reserved.

import subprocess
import shutil
import shlex
import argparse
import json
import zipfile
import os
import base64
import random
import socket

def rmfile(f):
    try:
        os.remove(f)
    except:
        pass

def rmdir(d):
    try:
        shutil.rmtree(d)
    except:
        pass

class Pollenc:

    def __init__ (self, args):
        self.args = args
        self.workname = 'pollenc' + str(os.getpid()) + '_' + str(random.randint(1, 10000))
        self.workzip = '/tmp/' + self.workname + '_src.zip'
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((args.host, args.port))

    #
    # begin comm
    #
    def write(self, msg):
        hmsg = "%i\n%s" % (len(msg), msg)
        self.sock.send(hmsg)
    
    def read(self):

        hlen = 0
        hlenRec = ''
        while True:
            b = self.sock.recv(1)
            if b == '\n':
                hlen = int(hlenRec)
                break
            hlenRec += b
        
        BUFSZ = 1024
        r = ''
        while len(r) < hlen:
            sz = BUFSZ
            rem = hlen - len(r)
            if rem < BUFSZ:
                sz = rem
            b = self.sock.recv(sz)
            r += b
        return r
    #
    # end comm
    #

    def filenameOk(self, file):
        if file.endswith('.zip'):
            return False
        if file.endswith('stderr'):
            return False
        if file.endswith('stdout'):
            return False
        if file.endswith('.out'):
            return False
        if file.endswith('.hex'):
            return False
        return True

    # bug!  why does this zip not create error when bogus
    # bug!  test by removing remove code
    # presumes path is the parent dir to the 'code' dir
    def zipdir(self, path, zip):
        origpath = os.getcwd()
        os.chdir(path)
        #for root, dirs, files in os.walk(path):
        for root, dirs, files in os.walk('.'):
            for file in files:
                if self.filenameOk(file):
                    print('adding %s' % (file))
                    zip.write(os.path.join(root, file))
        os.chdir(origpath)


    def makeCZip(self):

        zip = zipfile.ZipFile(self.workzip, 'w')
        ptmp = []
        if self.args.includes == None:
            ptmp.append('.')
        else:
            for d in self.args.includes:
                ptmp.append(d)

        tmpdir = '/tmp/' + self.workname
        for src in ptmp:
            rmdir(tmpdir)
            os.mkdir(tmpdir)
            shutil.copytree(src,tmpdir + '/code/')
            self.zipdir(tmpdir, zip)
            rmdir(tmpdir)
        zip.close()

    def makePollenZip(self):
        raise Exception('not implemented')

    def makezip(self):
       
        rmfile(self.workzip)

        if self.args.buildc:
            self.makeCZip()
        else:
            self.makePollenZip()

    def sendzip(self):
        file = open(self.workzip, "rb")
        data = ''
        while True:
            chunk = file.read(1024)
            if not chunk: 
                break  # EOF
            data += chunk
        file.close()
        b64data = base64.b64encode(data)

        jsonstr = '{\"buildenv\": \"%s\", \"tid\": \"%s\", \"aid\": \"%s\", \"reply\": \"%s\", \"type\": \"request\", \"service\": \"compile\", \"user\": {\"token\": \"%s\", \"id\": \"%s\", \"name\": \"%s\"}, \"project\": {\"id\": \"%s\", \"name\": \"%s\"}, \"content\" :  {\"source\":  \"%s\", \"filename\": \"%s\", \"partnum\": \"%s\" } }' % (args.buildenv, 0, 42, "dummy_replyTo", args.token, 12345678, None, 'myproj123', 'myproj', b64data, args.filename, args.mcu)
       
        self.write(jsonstr)

    def run(self):

        self.makezip()
        self.sendzip()

        while True:
            r = self.read()
            workobj   = json.loads(r)
            if workobj['type'] != 'response':
                print ('%s' % (workobj['content']['content']))
                continue
            if workobj['content']['error'] != 'None':
                print ('error! %s' % (workobj['content']['error']))
            break
        
        rmfile(self.workzip)

        b64 = workobj['content']['content']
        zipbytes = base64.b64decode(b64)
        unzip(zipbytes)
        if self.args.loader != None:
            self.loadHex()

    def loadHex(self):
        
        cmd = 'downloader'
        if self.args.mcu != None:
            cmd += ' -t ' + self.args.mcu
        if self.args.serial != None:
            cmd += ' -s ' + self.args.serial
        if self.args.baud != None:
            cmd += ' -b ' + self.args.baud
        if self.args.loader != None:
            cmd += ' -p ' + self.args.loader
        cmd += ' -c flash:w:a.out.hex'

        pipeCmd(cmd)


def unzip (src):
    tmpzip = 'a.zip'
    try:
        binfile = open(tmpzip, 'wb')
        binfile.write(src)
        binfile.close()
        z = zipfile.ZipFile(tmpzip)
        z.extractall('.')
        rmfile(tmpzip)
    except Exception, e:
        print("argh! %s" % (e))

def pipeCmd(command):

    commandOut = ""
    commandErr = ""
    try:
        process = subprocess.Popen(shlex.split(command), bufsize=4096, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (commandOut, commandErr) = process.communicate()
        process.wait()
    except Exception, e:
        print("Error! %s" % (str(e)))
        raise e;


if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--debug', dest='debug', action='store', help='debug')
    parser.add_argument('--build-c', dest='buildc', action='store_true', help='build c')
    parser.add_argument('--build-pollen', dest='buildpollen', action='store_true', help='build pollen')
    parser.add_argument('-l', '--loader', dest='loader', action='store', help='loader')
    parser.add_argument('-b', '--baud', dest='baud', action='store', help='baud')
    parser.add_argument('-s', '--serial', dest='serial', action='store', help='serial port')
    parser.add_argument('--host', dest='host', action='store', help='wind.io host', default="channel.wind.io")
    parser.add_argument('--port', dest='port', action='store', help='wind.io port', default=2323, type=int)
    parser.add_argument('--cflags', dest='cflags', action='store', help='append cflags')
    parser.add_argument('--set-cflags', dest='setcflags', action='store', help='cflags')
    parser.add_argument('-m', '--mcu',  dest='mcu', action='store', help='mcu', required=True)
    parser.add_argument('-E', '--buildenv',  dest='buildenv', action='store', help='build environment', required=True)
    parser.add_argument('-t', '--token',   dest='token', action='store', help='user credential', required=True)
    parser.add_argument('-i', '--include',   dest='includes', action='append', help='code dirs')
    parser.add_argument('filename', nargs='?')
        
    args = parser.parse_args()

    if args.buildpollen == True:
        args.buildc = False
    
    if args.filename == None:
        raise Exception('no filename specified')

    Pollenc(args).run() 

