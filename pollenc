#!/usr/bin/env python

# Copyright 2012, 2013 Amaret Inc. All rights reserved.

import sys
import subprocess
import shutil
import shlex
import argparse
import json
import zipfile
import os
import base64
import random
import socket

def rmfile(f):
    try:
        os.remove(f)
    except:
        pass

def rmdir(d):
    try:
        shutil.rmtree(d)
    except:
        pass

class Pollenc:

    def __init__ (self, args):
        self.args = args
        self.workname = 'pollenc' + str(os.getpid()) + '_' + str(random.randint(1, 10000))
        self.workzip = '/tmp/' + self.workname + '_src.zip'
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((args.host, args.port))

    #
    # begin comm
    #
    def write(self, msg):
        hmsg = "%i\n%s" % (len(msg), msg)
        self.sock.send(hmsg)
    
    def read(self):

        hlen = 0
        hlenRec = ''
        while True:
            b = self.sock.recv(1)
            if b == '\n':
                hlen = int(hlenRec)
                break
            hlenRec += b
        
        BUFSZ = 1024
        r = ''
        while len(r) < hlen:
            sz = BUFSZ
            rem = hlen - len(r)
            if rem < BUFSZ:
                sz = rem
            b = self.sock.recv(sz)
            r += b
        return r
    #
    # end comm
    #

    def filenameOk(self, file):
        if file.endswith('.zip'):
            return False
        if file.endswith('stderr'):
            return False
        if file.endswith('stdout'):
            return False
        if file.endswith('.out'):
            return False
        if file.endswith('.hex'):
            return False
        return True

    def zipdir(self, path, zip):
        origpath = os.getcwd()
        os.chdir(path)
        namelist = ''
        for root, dirs, files in os.walk('.'):
            for file in files:
                if self.filenameOk(file):
                    namelist += file + ' '
                    zip.write(os.path.join(root, file))
        print('preparing %s' % (namelist))
        os.chdir(origpath)


    def makeCZip(self):

        zip = zipfile.ZipFile(self.workzip, 'w')
        ptmp = []
        if self.args.includes == None:
            ptmp.append('.')
        else:
            for d in self.args.includes:
                ptmp.append(d)

        tmpdir = '/tmp/' + self.workname
        for src in ptmp:
            rmdir(tmpdir)
            os.mkdir(tmpdir)
            shutil.copytree(src,tmpdir + '/code/')
            self.zipdir(tmpdir, zip)
            rmdir(tmpdir)
        zip.close()

    def makePollenZip(self):
        zip = zipfile.ZipFile(self.workzip, 'w')
        ptmp = []
        if self.args.includes == None:
            raise Exception('-i required')
        else:
            for d in self.args.includes:
                ptmp.append(d)

        tmpdir = '/tmp/' + self.workname
        for src in ptmp:
            if not os.path.exists(src):
                continue #system bundle
            rmdir(tmpdir)
            os.mkdir(tmpdir)
            shutil.copytree(src,tmpdir + '/' + src)
            self.zipdir(tmpdir, zip)
        zip.close()
        rmdir(tmpdir)

    def makezip(self):
       
        rmfile(self.workzip)

        if self.args.buildc:
            self.makeCZip()
        else:
            self.makePollenZip()

    def sendzip(self):
        file = open(self.workzip, "rb")
        data = ''
        while True:
            chunk = file.read(1024)
            if not chunk: 
                break  # EOF
            data += chunk
        file.close()
        b64data = base64.b64encode(data)
        rmfile(self.workzip)

        jsonobj = {'buildenv': self.args.buildenv, 
                   'tid': 0,
                   'aid': 0,
                   'reply': 'dummy', 
                   'type': 'request', 
                   'service': 'compile', 
                   'user': {
                       'token': self.args.token, 
                       'id': 0, 
                       'name': 'None'
                       },
                   'project': {
                       'id': 0, 
                       'name': 'None'
                       }, 
                   'content' :  {
                       'source':  b64data, 
                       'filename': self.args.filename, 
                       'outdir': self.args.outdir, 
                       'partnum': self.args.mcu
                       }
                   }
        if self.args.buildpollen:
            jsonobj['content']['bundlenames'] = self.args.includes
        jsonobj['content']['getbuild'] = self.args.getbuild
        
        jsonstr = json.dumps(jsonobj)
        print(jsonstr)
        self.write(jsonstr)

    def run(self):

        self.makezip()
        self.sendzip()

        while True:
            r = self.read()
            workobj = json.loads(r)
            if workobj['type'] != 'response':
                print ('%s' % (workobj['content']['content']))
                continue
            if workobj['content']['error'] != 'None':
                print ('error! %s' % (workobj['content']['error']))
                return
            break
        
        rmfile(self.workzip)

        b64 = workobj['content']['content']
        zipbytes = base64.b64decode(b64)
        origpath = os.getcwd()
        os.chdir(self.args.outdir)
        unzip(zipbytes)
        os.chdir(origpath)
        if self.args.loader != None:
            self.loadHex()

    def getPackageName(self):
        (head, modulename) = os.path.split(self.getFilename())
        (head, pkgname) = os.path.split(head)
        return pkgname

    def getModuleName(self):
        (head, modulename) = os.path.split(self.getFilename())
        return modulename
     
    def getFilename(self):
        return self.args.filename

    def getOutDir(self):
        return self.args.outdir
     
    def getOutRootName(self):
        return self.getOutDir() + '/' + self.getPackageName() + '/' + self.getModuleName() + '/' + self.getModuleName()

    def getProgName(self):
        return self.getOutRootName() + '-prog.c'

    def getMapName(self):
        return self.getOutRootName() + '-prog.map'

    def getHexName(self):
        if self.args.buildpollen:
            n = self.getOutRootName() + '-prog.hex'
            return n
        n = self.getOutDir() + '/' + self.getProgRootName() + '.out.hex'
        return n

    def getProgRootName(self):
        return os.path.splitext(self.getFilename())[0]

    def getOutName(self):
        return self.getOutRootName() + '-prog.out'

    def loadHex(self):
        
        cmd = 'downloader'
        if self.args.mcu != None:
            cmd += ' -t ' + self.args.mcu
        if self.args.serial != None:
            cmd += ' -s ' + self.args.serial
        if self.args.baud != None:
            cmd += ' -b ' + self.args.baud
        if self.args.loader != None:
            cmd += ' -p ' + self.args.loader
        cmd += ' -c flash:w:' + self.getHexName()

        pipeCmd(cmd)


def unzip (src):
    tmpzip = 'a.zip'
    try:
        binfile = open(tmpzip, 'wb')
        binfile.write(src)
        binfile.close()
        z = zipfile.ZipFile(tmpzip)
        z.extractall('.')
        rmfile(tmpzip)
    except Exception, e:
        print("argh! %s" % (e))

def pipeCmd(command):

    commandOut = ""
    commandErr = ""
    try:
        process = subprocess.Popen(shlex.split(command), bufsize=4096, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (commandOut, commandErr) = process.communicate()
        process.wait()
    except Exception, e:
        print("Error! %s" % (str(e)))
        raise e;


if __name__ == "__main__":

    parser = argparse.ArgumentParser()

    parser.add_argument('-d', '--debug', 
            dest='debug', action='store_true', help='debug')

    parser.add_argument('--build-c', 
            dest='buildc', action='store_true', help='build c')

    parser.add_argument('--build-pollen', 
            dest='buildpollen', action='store_true', help='build pollen')

    parser.add_argument('--get-build', 
            dest='getbuild', action='store_true', help='return all build files')

    parser.add_argument('-l', '--loader', 
            dest='loader', action='store', help='loader')

    parser.add_argument('-b', '--baud', 
            dest='baud', action='store', help='baud')

    parser.add_argument('-s', '--serial', 
            dest='serial', action='store', help='serial port')

    parser.add_argument('--host', 
            dest='host', action='store', help='wind.io host', default="channel.wind.io")

    parser.add_argument('--port', 
            dest='port', action='store', help='wind.io port', default=2323, type=int)

    parser.add_argument('--cflags', 
            dest='cflags', action='store', help='append cflags')

    parser.add_argument('--set-cflags', 
            dest='setcflags', action='store', help='cflags')

    parser.add_argument('--ldflags', 
            dest='cflags', action='store', help='append ldflags')

    parser.add_argument('--set-ldflags', 
            dest='setcflags', action='store', help='ldflags')

    parser.add_argument('-m', '--mcu',  
            dest='mcu', action='store', help='mcu', required=True)

    parser.add_argument('-E', '--buildenv', 
            dest='buildenv', action='store', help='build environment', required=True)

    parser.add_argument('-t', '--token', 
            dest='token', action='store', help='user credential', required=True)

    parser.add_argument('-o', '--out', 
            dest='outdir', action='store', help='output dir', required=True)

    parser.add_argument('-i',
            dest='includes', action='append', help='code dirs')

    parser.add_argument('filename', nargs='?')

    #todo:
    # --get-build
    # cflags / setcflags
    # ldflags / setldlags
        
    args = parser.parse_args()

    if args.filename == None:
        print('no filename specified')
        sys.exit(0)

    if args.buildc == False:
        args.buildpollen = True #default
    if args.buildpollen == True:
        args.buildc = False
    
    if os.path.exists(args.outdir):
        rmdir(args.outdir)
    os.mkdir(args.outdir)

    Pollenc(args).run() 

